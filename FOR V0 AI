#include <Wire.h>
#include <U8g2lib.h>
#include <SoftwareSerial.h>
#include <Keyboard.h>
#include <WiFiS3.h>
#include <ArduinoHttpClient.h>
#include <TimeLib.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
#include <LiquidCrystal_I2C.h>
#include <ArduinoJson.h>  // Added for better JSON handling

// OLED Display Setup
U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0);

// LCD I2C Setup
LiquidCrystal_I2C lcd(0x27, 16, 2);

// QR Scanner Serial Setup
#define RX_PIN 2  
#define TX_PIN 3  
SoftwareSerial qrScanner(RX_PIN, TX_PIN);

// LED Pins
#define RED_LED 4    
#define GREEN_LED 5  

// Relay Pin
#define RELAY_PIN 6  // Define the pin connected to the relay

// WiFi & Firebase Setup
const char* WIFI_SSID = "Shayn";
const char* WIFI_PASSWORD = "123456789";
const char* FIREBASE_HOST = "sammuel-17249-default-rtdb.firebaseio.com";

// Connection retry parameters
#define MAX_WIFI_ATTEMPTS 20
#define WIFI_RETRY_DELAY 1000

// System timing parameters
#define SCANNER_OFF_DURATION 30000  // 30 seconds in milliseconds
#define AUTO_LOCK_TIMEOUT 1800000   // 30 minutes in milliseconds - auto lock if inactive
#define NTP_UPDATE_INTERVAL_MS 60000  // Update time every minute

WiFiSSLClient wifiClient;
HttpClient httpClient(wifiClient, FIREBASE_HOST, 443);

// NTP Client Setup
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org");
#define GMT_OFFSET_SEC 8 * 3600  // Change this to your timezone offset in seconds (e.g., GMT+8 = 8*3600)

// Month names array for formatting
const char* monthNames[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

// System state variables
bool locked = true; 
bool scanComplete = false;
bool firstScanDone = false;  // Flag to track if first scan is done
String lastQRData = "";      // Store the QR data from first scan
unsigned long lastNtpUpdate = 0;
unsigned long firstScanTime = 0;  // Time when first scan was completed
unsigned long lastActivityTime = 0; // For auto-lock feature

// Relay timing variables
unsigned long relayStartTime = 0;
bool relayActive = false;
unsigned long scannerOffTime = 0;
bool scannerOff = false;

// Initial time setup as fallback
#define INITIAL_YEAR 2025
#define INITIAL_MONTH 3
#define INITIAL_DAY 13
#define INITIAL_HOUR 3
#define INITIAL_MINUTE 11
#define INITIAL_SECOND 0

// Function prototypes
void displayMessage(const char *message);
void displayQRData(String data);
bool sendDataToFirebase(String qrData, bool isTimeIn);
String readQRData();
bool connectToWiFi();
String getFormattedDate();
String getFormattedTime();
void setupTime();
bool updateTimeFromNTP();
void updateLCDMessage(const char *line1, const char *line2);
void unlockPC();
void lockPC();
void checkAutoLock();

void setup() {
    Serial.begin(115200);
    
    // Initialize LCD first thing
    lcd.init();
    lcd.backlight();
    updateLCDMessage("AUTHENTIKEY", "SYSTEM");
    
    // Add a longer delay for welcome message to be visible
    delay(2000);
    
    // Initialize other components
    u8g2.begin();
    pinMode(RED_LED, OUTPUT);
    pinMode(GREEN_LED, OUTPUT);
    pinMode(RELAY_PIN, OUTPUT);  // Initialize relay pin
    digitalWrite(RED_LED, LOW);
    digitalWrite(GREEN_LED, LOW);
    digitalWrite(RELAY_PIN, LOW);  // Ensure relay is off initially

    displayMessage("Initializing...");
    delay(1000);

    // Initialize scanner with debug message
    qrScanner.begin(9600);
    Serial.println("QR Scanner initialized on pins RX:" + String(RX_PIN) + " TX:" + String(TX_PIN));
    Keyboard.begin();

    // Use initial time as fallback
    setupTime();
    Serial.println("Initial time set to: " + getFormattedDate() + " " + getFormattedTime());

    digitalWrite(RED_LED, HIGH);
    displayMessage("System Locked");
    delay(1000);

    // Connect to WiFi with retry
    bool wifiConnected = connectToWiFi();
    
    // Initialize and update NTP client after WiFi is connected
    if (wifiConnected) {
        timeClient.begin();
        timeClient.setTimeOffset(GMT_OFFSET_SEC);
        updateTimeFromNTP();
    } else {
        displayMessage("Offline Mode");
        delay(2000);
    }
    
    // Set initial state
    if (locked) {
        displayMessage("Scan for Time-In");
    }
    
    // Initialize last activity time
    lastActivityTime = millis();
}

void setupTime() {
    // Set the time to the values defined in the initial constants as fallback
    setTime(INITIAL_HOUR, INITIAL_MINUTE, INITIAL_SECOND, INITIAL_DAY, INITIAL_MONTH, INITIAL_YEAR);
}

bool updateTimeFromNTP() {
    Serial.println("Updating time from NTP server...");
    displayMessage("Syncing time...");
    
    bool success = false;
    int attempts = 0;
    
    while (!success && attempts < 3) {
        if (timeClient.update()) {
            // Get full date and time from NTP
            unsigned long epochTime = timeClient.getEpochTime();
            
            // Convert to time_t and sync with TimeLib
            setTime(epochTime);
            
            Serial.println("✅ NTP time sync successful!");
            Serial.println("Current time: " + getFormattedDate() + " " + getFormattedTime());
            displayMessage("Time synced!");
            delay(1000);
            
            if (locked) {
                displayMessage("Scan for Time-In");
            } else {
                displayMessage("Scan To Lock");
            }
            
            lastNtpUpdate = millis();
            success = true;
        } else {
            Serial.println("NTP time sync attempt " + String(attempts + 1) + " failed");
            attempts++;
            delay(1000);
        }
    }
    
    if (!success) {
        Serial.println("❌ NTP time sync failed after " + String(attempts) + " attempts!");
        displayMessage("Time sync failed");
        delay(1000);
        
        if (locked) {
            displayMessage("Scan for Time-In");
        } else {
            displayMessage("Scan To Lock");
        }
    }
    
    return success;
}

void loop() {
    // Check if it's time to update from NTP
    if (WiFi.status() == WL_CONNECTED && (millis() - lastNtpUpdate > NTP_UPDATE_INTERVAL_MS)) {
        updateTimeFromNTP();
    }
    
    // Check for auto-lock if system is unlocked
    if (!locked) {
        checkAutoLock();
    }
    
    // Handle scanner reactivation after timeout
    if (scannerOff && (millis() - scannerOffTime >= SCANNER_OFF_DURATION)) {
        digitalWrite(RELAY_PIN, LOW);  // Turn on the scanner by deactivating the relay
        scannerOff = false;            // Reset scanner off flag
        scanComplete = false;          // Reset scan complete flag to allow new scans
        
        // Update display based on system state
        if (locked) {
            digitalWrite(RED_LED, HIGH);
            digitalWrite(GREEN_LED, LOW);
            displayMessage("Scan for Time-In");
        } else {
            digitalWrite(RED_LED, LOW);
            digitalWrite(GREEN_LED, HIGH);
            displayMessage("Scan To Lock");
        }
        
        Serial.println("Scanner reactivated after timeout");
    }
    
    if (qrScanner.available() && !scanComplete) {
        String qrData = readQRData();
        
        Serial.println("QR Data received: " + qrData);
        Serial.println("QR Data length: " + String(qrData.length()));
        
        // Check if QR data is valid
        if (qrData.length() == 11 && qrData.startsWith("UA") && qrData.substring(2).toInt() > 0) {  
            scanComplete = true;  
            Serial.println("Valid QR Data: " + qrData);
            displayQRData(qrData);
            
            // Update last activity time
            lastActivityTime = millis();
            
            // Turn off the scanner by activating the relay
            digitalWrite(RELAY_PIN, HIGH);
            scannerOffTime = millis();  // Record when we turned off the scanner
            scannerOff = true;          // Set scanner off flag

            // Check if the system is locked or unlocked
            if (locked) {
                // This is the first scan - unlock the system
                lastQRData = qrData;    // Store QR data for verification on second scan
                firstScanDone = true;   // Set first scan flag
                unlockPC();             // Call the unlock function
                locked = false;         // Unlock the system
                
                digitalWrite(RED_LED, LOW);
                digitalWrite(GREEN_LED, HIGH);
                
                displayMessage("System Unlocked");
                delay(1000);
                displayMessage("Scanner Off 30s");
                
                // Send data to Firebase - time in
                sendDataToFirebase(qrData, true);
            } else {
                // This is the second scan - lock the system
                if (qrData == lastQRData) {
                    // Same QR code - proceed with lock
                    lockPC();           // Call the lock function
                    locked = true;      // Lock the system
                    firstScanDone = false; // Reset first scan flag
                    
                    digitalWrite(GREEN_LED, LOW);
                    digitalWrite(RED_LED, HIGH);
                    
                    displayMessage("System Locked");
                    delay(1000);
                    displayMessage("Scanner Off 30s");
                    
                    // Send data to Firebase - time out
                    sendDataToFirebase(qrData, false);
                } else {
                    // Different QR code - reject
                    displayMessage("QR Code Mismatch!");
                    delay(2000);
                    displayMessage("Scanner Off 30s");
                }
            }
        } else if (qrData.length() > 0) {
            // We got data but it doesn't match our format
            Serial.println("Invalid QR format: " + qrData);
            displayMessage("Invalid QR code");
            delay(2000);
            
            // Still turn off scanner for invalid QR
            digitalWrite(RELAY_PIN, HIGH);
            scannerOffTime = millis();
            scannerOff = true;
            displayMessage("Scanner Off 30s");
        }
    }
    
    // Display countdown timer while scanner is off
    if (scannerOff) {
        unsigned long timeRemaining = SCANNER_OFF_DURATION - (millis() - scannerOffTime);
        if (timeRemaining > 0 && timeRemaining % 1000 < 50) {  // Update roughly every second
            char countdownMsg[20];
            sprintf(countdownMsg, "Scanner: %ds", (int)(timeRemaining/1000));
            u8g2.clearBuffer();
            u8g2.setFont(u8g2_font_6x10_mr);
            u8g2.drawStr(0, 10, countdownMsg);
            u8g2.drawStr(0, 30, locked ? "System Locked" : "System Unlocked");
            u8g2.sendBuffer();
        }
    }
}

void checkAutoLock() {
    // Check if auto-lock timeout has been reached
    if (millis() - lastActivityTime >= AUTO_LOCK_TIMEOUT) {
        Serial.println("Auto-lock triggered due to inactivity");
        displayMessage("Auto-locking...");
        delay(1000);
        
        // Lock the PC
        lockPC();
        locked = true;
        firstScanDone = false;
        
        digitalWrite(GREEN_LED, LOW);
        digitalWrite(RED_LED, HIGH);
        
        displayMessage("System Locked");
        delay(1000);
        
        // Send data to Firebase if we have a valid QR code
        if (lastQRData.length() > 0) {
            sendDataToFirebase(lastQRData, false);
        }
        
        // Reset scanner state
        scanComplete = false;
        scannerOff = false;
        digitalWrite(RELAY_PIN, LOW);  // Ensure scanner is on
        
        displayMessage("Scan for Time-In");
    }
}

String getFormattedDate() {
    // Format date as "Mmm dd yyyy" (e.g., "Mar 14 2025")
    char dateBuffer[12];
    sprintf(dateBuffer, "%s %d %04d", 
            monthNames[month() - 1], day(), year());
    return String(dateBuffer);
}

String getFormattedTime() {
    // Format time as "hh:mm:ss AM/PM" (e.g., "02:30:45 PM")
    char timeBuffer[12];
    int h = hour();
    const char* ampm = h >= 12 ? "PM" : "AM";
    h = h > 12 ? h - 12 : h;  // Handle 24-hour to 12-hour conversion
    h = h == 0 ? 12 : h;      // Handle midnight (0 hour) as 12 AM
    
    sprintf(timeBuffer, "%02d:%02d:%02d %s", 
            h, minute(), second(), ampm);
    return String(timeBuffer);
}

bool sendDataToFirebase(String qrData, bool isTimeIn) {
    // Get current date and time at the moment of scanning
    String formattedDate = getFormattedDate();
    String formattedTime = getFormattedTime();
    
    // Create a path using the QR code as a key
    String sanitizedDate = formattedDate;
    sanitizedDate.replace(" ", "_");  // Replace spaces with underscores
    
    // Generate a timestamp-based ID for this scan session
    unsigned long epochTime = (unsigned long)now();  
    String timestamp = String(epochTime);
    
    // Create the path - organizing by QR code, then by session timestamp
    String path = "/scannedData/" + qrData + "/sessions/" + timestamp + ".json";
    
    // Create JSON data using ArduinoJson
    StaticJsonDocument<200> doc;
    doc["date"] = formattedDate;
    doc["time"] = formattedTime;
    doc["status"] = isTimeIn ? "in" : "out";
    
    String jsonData;
    serializeJson(doc, jsonData);

    Serial.println("Sending data to Firebase...");
    Serial.println("Path: " + path);
    Serial.println("Data: " + jsonData);

    // Check if WiFi is connected
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi not connected. Cannot send data to Firebase.");
        displayMessage("WiFi Disconnected");
        delay(1000);
        return false;
    }

    // Set timeout and send request
    httpClient.setTimeout(5000);
    httpClient.beginRequest();
    httpClient.put(path);  // Using PUT instead of POST to set data at a specific path
    httpClient.sendHeader("Content-Type", "application/json");
    httpClient.sendHeader("Content-Length", jsonData.length());
    httpClient.beginBody();
    httpClient.print(jsonData);
    httpClient.endRequest();

    int statusCode = httpClient.responseStatusCode();
    String response = httpClient.responseBody();

    Serial.print("HTTP Status code: ");
    Serial.println(statusCode);
    Serial.println("Firebase Response: " + response);

    if (statusCode == 200) {
        Serial.println("✅ Data sent successfully!");
        
        // Display time info on OLED
        u8g2.clearBuffer();
        u8g2.setFont(u8g2_font_6x10_mr);
        u8g2.drawStr(0, 10, "QR Scanned:");
        u8g2.drawStr(0, 20, qrData.c_str());
        u8g2.drawStr(0, 30, isTimeIn ? "Time IN:" : "Time OUT:");
        u8g2.drawStr(0, 40, formattedTime.c_str());
        u8g2.drawStr(0, 50, formattedDate.c_str());
        u8g2.sendBuffer();
        return true;
    } else {
        Serial.println("❌ Failed to send data!");
        displayMessage("Firebase Error");
        delay(1000);
        return false;
    }
}

void displayMessage(const char *message) {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_6x10_mr);
    u8g2.drawStr(0, 10, message);
    u8g2.sendBuffer();
    
    // Also update LCD with the message
    updateLCDMessage("AUTHENTIKEY", message);
}

void displayQRData(String data) {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_6x10_mr);
    u8g2.drawStr(0, 10, "QR Scanned:");
    u8g2.drawStr(0, 20, data.c_str());
    u8g2.sendBuffer();
    
    // Update LCD
    updateLCDMessage("QR Scanned", data.c_str());
}

bool connectToWiFi() {
    Serial.print("Connecting to WiFi: ");
    Serial.println(WIFI_SSID);
    
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    
    displayMessage("Connecting WiFi...");
    
    int attempts = 0;
    while (attempts < MAX_WIFI_ATTEMPTS) {
        delay(WIFI_RETRY_DELAY);
        Serial.print(".");
        
        if (WiFi.status() == WL_CONNECTED) {
            Serial.println("\n✅ WiFi Connected!");
            Serial.print("IP Address: ");
            Serial.println(WiFi.localIP());
            
            // Check if IP is valid
            if (WiFi.localIP()[0] != 0) {
                displayMessage("WiFi Connected");
                delay(1500);
                return true;
            } else {
                Serial.println("Invalid IP address. Waiting for valid IP...");
            }
        }
        attempts++;
    }
    
    Serial.println("\n❌ WiFi Connection Failed!");
    Serial.print("WiFi Status: ");
    Serial.println(WiFi.status());
    displayMessage("WiFi Failed!");
    delay(2000);
    return false;
}

void unlockPC() {
    Serial.println("Unlocking PC...");
    displayMessage("Unlocking PC...");
    delay(500);  
    Keyboard.press(KEY_F1);
    delay(100);
    Keyboard.releaseAll();
    delay(500);
    Keyboard.print("090503");
    delay(500);
    Keyboard.press(KEY_RETURN);
    delay(100);
    Keyboard.releaseAll();
}

void lockPC() {
    Serial.println("Locking PC...");
    displayMessage("Locking PC...");
    Keyboard.press(KEY_LEFT_GUI);
    Keyboard.press('l');
    delay(100);
    Keyboard.releaseAll();
}

String readQRData() {
    String data = "";
    unsigned long startTime = millis();
    
    // Increase timeout to 3 seconds
    while (millis() - startTime < 3000) {
        if (qrScanner.available()) {
            char c = qrScanner.read();
            // Debug what's being received
            Serial.print("Scanner received char: ");
            Serial.print(c);
            Serial.print(" (hex: ");
            Serial.print(c, HEX);
            Serial.println(")");
            
            if (c == '\n') break;
            data += c;
            startTime = millis(); // Reset timeout when we receive data
        }
    }
    data.trim();
    Serial.println("QR Data read complete: " + data);
    return data;
}

// Function to update LCD display
void updateLCDMessage(const char *line1, const char *line2) {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(line1);
    lcd.setCursor(0, 1);
    lcd.print(line2);
}

